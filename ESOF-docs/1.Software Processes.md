##Processo de Desenvolvimento

###Descrição

Inicialmente a impressão obtida pelo grupo quanto ao processo de desenvolvimento seguido pelo “***The Borg Collective***” foi de que se tratava de um “*Incremental development and delivery*” devido aos seguintes aspetos:
* À análise das diferentes “*Milestones*” definidas no repositório que demonstravam que estavam a ser especificados os próximos incrementos do projeto.
* O recurso à framework “*Travis CI*” para validação do estado do projeto.

Com este método ágil de desenvolvimento,  a sua sobrevivência depende dos contribuidores. Graças a eles mais issues são detectadas e bugs são corrigidos, contrastando com o desenvolvimento tradicional de software.

No entanto na busca de uma opinião mais construtiva , decidimos contactar a comunidade do Borg, a qual nos explicou que não segue nenhum tipo de processo de desenvolvimento específico.

Borg trata-se de um  **FOSS**(*Free Open Source Software*), e segue a filosofia deste tipo de projetos ou seja, ao contrário do desenvolvimento comercial de software, o seu sucesso, temporal e funcional, depende da participação dos contribuidores / utilizadores. A citação do utilizador “*Florian Apolloner*”, membro ativo e conhecedor do projeto, quando questionado no IRC sobre o processo de desenvolvimento seguido, "*whoever does something, does something development*", descreve a flexibilidade e liberdade de desenvolvimento de cada módulo do software.

Embora seja um ambiente aberto de desenvolvimento são seguidas algumas regras e existe uma metodologia que segundo a comunidade se assemelha bastante à descrita no seguinte [link](https://rfc.unprotocols.org/spec:1/C4/).

As principais diretrizes dizem respeito a como e em que circunstâncias devem ser criadas “*issues*”, “*pull requests*” e a forma como os “*maintainers*” do projeto devem gerir e ser geridos.


###Opiniões, Críticas e Alternativas
Na nossa opinião, a técnica utilizada não será a mais indicada para um projeto de uma empresa que pretenda mostrar o seu valor no mundo empresarial, mas é uma técnica razoavelmente boa para um projeto open source, dado que permite aos contribuidores terem grande facilidade em se integrarem na equipa de desenvolvimento, algo que o nosso grupo denotou desde cedo nesta comunidade.

O repositório organiza-se em *branches*, cada um destinado a novas features, responsáveis pelo paralelismo do desenvolvimento. O repositório também conta com um conjunto de *milestones*, sem data de *release* definida (para um desenvolvimento mais relaxado), que objetivam a evolução do software. O conjunto de *issues* devidamente identificadas e categorizadas são mais um fator positivo quer para a organização do projeto quer para a comunicação entre os contribuidores.

Com a variedade de personalidades e ”standards”,a imposição de normas, descritas na secção anterior, providência o entendimento e a ordem entre os diferentes contribuidores, facilitando a participação e integração.

Comparando com outros métodos de desenvolvimento, ”*Waterfall model*” não seria o mais adequado devido à expansão para diferentes plataformas e às constantes adições/alterações que podem ocorrer a qualquer momento, quer nas dependências quer com novas técnicas. Este modelo não iria permitir a flexibilidade necessária para o desenvolvimento projeto.

Em contraste, o “*Iterative and Incremental development model*” parece ser uma boa opção para este programa, visto que, é possível termos várias iterações do projeto a serem desenvolvidas em paralelo (por exemplo, a versão para windows) de forma a que a qualquer momento no tempo, podemos ter vários membros a trabalhar para diversos milestones, distribuindo tarefas e otimizando as contribuições dos vários “developers”, algo que proporciona uma maior flexibilidade em termos de adaptação e mudança, uma vez que ao ser atualizada uma das tecnologias utilizadas é possível voltar a iterar e incrementar as funcionalidades baseadas nessa atualização.

De notar que o grupo considerou também o método de “*Incremental Prototyping*” pois um protótipo incremental seria benéfico para qualquer projeto, dado que permite uma maior interação com o cliente o que leva a uma deteção de erros/falhas e até mesmo à descoberta de desentendimentos entre as especificações pedidas e as interpretadas, pelo que seria possível diminuir o custo do projeto, descobrindo estas falhas numa fase mais inicial. Porém após uma pesquisa mais aprofundada a este processo em específico descobrimos que é um processo mais orientado a programas que dependem bastante na interface com o utilizador, pois permite obter feedback mais rápido e frequente, algo que não é de todo uma má prática mas que no nosso caso não é tão útil.

###Contribuições
* [David Azevedo](https://github.com/PeaceOff) : ⅓ * 100%
* [João Ferreira](https://github.com/joaocsf) : ⅓ * 100%
* [José Martins](https://github.com/JoseLuisMartins) : ⅓ * 100%
