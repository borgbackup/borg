from typing import BinaryIO, NamedTuple, Tuple, Union, IO, Iterator, Any

API_VERSION: str

PATH_OR_FILE = Union[str, IO]

class ChunkIndexEntry(NamedTuple):
    flags: int
    size: int

CIE = Union[Tuple[int, int], ChunkIndexEntry]

class ChunkIndex:
    F_NONE: int
    F_USED: int
    F_COMPRESS: int
    F_NEW: int
    M_USER: int
    M_SYSTEM: int
    def add(self, key: bytes, size: int) -> None: ...
    def iteritems(self, *, only_new: bool = ...) -> Iterator: ...
    def clear_new(self) -> None: ...
    @classmethod
    def read(cls, path: BinaryIO | str | bytes) -> "ChunkIndex": ...
    def write(self, path: BinaryIO | str | bytes) -> None: ...
    @property
    def stats(self) -> dict[str, int]: ...
    def k_to_idx(self, key: bytes) -> int: ...
    def idx_to_k(self, entry: int) -> bytes: ...
    def __contains__(self, key: bytes) -> bool: ...
    def __getitem__(self, key: bytes) -> ChunkIndexEntry: ...
    def __setitem__(self, key: bytes, value: CIE) -> None: ...
    def clear(self) -> None: ...
    def get(self, key: bytes, default: ChunkIndexEntry | None = ...) -> ChunkIndexEntry | None: ...
    def items(self) -> Iterator[Tuple[bytes, ChunkIndexEntry]]: ...
    def __len__(self) -> int: ...

class NSIndex1Entry(NamedTuple):
    segment: int
    offset: int

class NSIndex1:  # legacy
    def iteritems(self, *args, **kwargs) -> Iterator: ...
    def __contains__(self, key: bytes) -> bool: ...
    def __getitem__(self, key: bytes) -> Any: ...
    def __setitem__(self, key: bytes, value: Any) -> None: ...

class FuseVersionsIndexEntry(NamedTuple):
    version: int
    hash: bytes

class FuseVersionsIndex:
    def __contains__(self, key: bytes) -> bool: ...
    def __getitem__(self, key: bytes) -> Any: ...
    def __setitem__(self, key: bytes, value: Any) -> None: ...
